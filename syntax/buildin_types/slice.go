package main

import "fmt"

// 注意：切片的容量是指的切片最多放多少元素
func Slice() {
	//声明一个切片，也就是不给长度的数组
	s1 := []int{1, 5, 8}
	//%v直接打印整个切片，len求出长度的方法，cap求出容量的方法
	fmt.Printf("s1: %v, len=%d, cap=%d \n", s1, len(s1), cap(s1))

	//还可以使用make创建一个切片,第一个参数长度，第二个是容量
	s2 := make([]int, 3, 4)
	fmt.Printf("s2: %v, len=%d, cap=%d \n", s2, len(s2), cap(s2))

	//如果使用make,指定了类型，后面只有一个参数，那么长度和容量都是一样的，这里是4
	s3 := make([]int, 4)
	fmt.Printf("s3: %v, len=%d, cap=%d \n", s3, len(s3), cap(s3))

	//声明一个长度为0，容量为4的切片
	s4 := make([]int, 0, 4)
	//给这个切片添加一个元素1，那么他的长度就是1
	s4 = append(s4, 1)
	s4 = append(s4, 1)
	s4 = append(s4, 1)
	s4 = append(s4, 1)
	//这是第五个执行的元素，切片就扩容了
	s4 = append(s4, 1)
	fmt.Printf("s4: %v, len=%d, cap=%d \n", s4, len(s4), cap(s4))

	//最佳实践：初始化切片的时候，尽量预估容量，如果是在不好预估，最好和实际相差不大的，避免多次扩容

	//遇事不决，最好使用切片，可以不用数组；数组是明确知道容量的情况下使用

	//注意：
	//1.切片的操作是有限的，不支持随机的增删，（即没有add,delete方法，需要自己写代码）
	//2.只有append操作，但是数组没有append操作
	//3.切片支持原子操作，和原来的切片是共享底层数组
	//4.切片支持make创建，但是数组不支持
	//5.切片支持扩容，但是数组不支持
	//6.切片的底层还是数组
}

// 子切片
func subSlice() {
	s1 := []int{2, 4, 6, 8, 10}
	//含头不含尾从下标1开始，3结束，但是不包含3，但是容量是从1开始的，所以容量是4
	s2 := s1[1:3]
	//下面打印出来的是{4，6}，长度是2，容量是4
	fmt.Printf("s2: %v, len=%d, cap=%d \n", s2, len(s2), cap(s2))

	//[1:6]下面的超出切片范围了，长度超了，由于含头不含尾，所以下面最大值就是[1,5]
	s3 := s1[1:5]
	fmt.Printf("s3: %v, len=%d, cap=%d \n", s3, len(s3), cap(s3))

	//这样写，从下标2开始取值，一直取完，这里就是长度就是3，容量也是3
	s4 := s1[2:]
	fmt.Printf("s4: %v, len=%d, cap=%d \n", s4, len(s4), cap(s4))

	//这样写，下标长度取值到3，但是不包含3，取值为[2,4,6],长度是3，没有指定开始值，
	//那么容量是从0开始，到最大值，也就是5
	s5 := s1[:3]
	fmt.Printf("s5: %v, len=%d, cap=%d \n", s5, len(s5), cap(s5))

	//总结：
	//子切片和切片之间是否共享数组，要看子切片是否发生扩容，没有发生，就是共享，发生了，就是不是共享

}
